Kora Full Transaction Flow
This guide teaches you how to implement a complete gasless transaction flow using Kora RPC, including payment instructions and transaction signing.

Last Updated: 2025-10-31

What You'll Build
In the Quick Start Guide, you learned how to set up Kora RPC and make basic calls. Now we'll build a complete gasless transaction system that demonstrates Kora's full capabilities. By the end of this guide, you'll have implemented a transaction flow that:

Creates multiple transfer instructions (SPL tokens and SOL)
Obtains payment instructions from Kora for fee coverage
Signs transactions with user keys while Kora handles gas fees
Submits fully-signed transactions to the Solana network
The final result will be a working gasless transaction system:


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
KORA GASLESS TRANSACTION DEMO
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[1/6] Initializing clients
  → Kora RPC: http://localhost:8080/
  → Solana RPC: http://127.0.0.1:8899
[2/6] Setting up keypairs
  → Sender: BYJVBqQ2xV9GECc84FeoPQy2DpgoonZQFQu97MMWTbBc
  → Destination: C8MC9E6nf9Am1rVqdDedDavm53uCJMiSwarEko1aXmny
  → Kora signer address: 3Z1Ef7YaxK8oUMoi6exf7wYZjZKWJJsrzJXSt1c3qrDE
[3/6] Creating demonstration instructions
  → Payment token: 9BgeTKqmFsPVnfYscfM6NvsgmZxei7XfdciShQ6D3bxJ
  ✓ Token transfer instruction created
  ✓ SOL transfer instruction created
  ✓ Memo instruction created
  → Total: 3 instructions
[4/6] Estimating Kora fee and assembling payment instruction
  → Fee payer: 3Z1Ef7Ya...
  → Blockhash: 7HZUaMqV...
  ✓ Estimate transaction built
  ✓ Payment instruction received from Kora
[5/6] Creating and signing final transaction (with payment)
  ✓ Final transaction built with payment
  ✓ Transaction signed by user
[6/6] Signing transaction with Kora and sending to Solana cluster
  ✓ Transaction co-signed by Kora
  ✓ Transaction submitted to network
  ⏳ Awaiting confirmation...
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
SUCCESS: Transaction confirmed on Solana
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Transaction signature:
41hmwmkMfHR5mmhG9sNkjiakwHxpmr1H3Gi3bBL8v5PbsRrH7FhpUT8acHaf2mrPKNVD894dSYXfjp6LfAbVpcCE
View on explorer:
https://explorer.solana.com/tx/41hmwmkMfHR5mmhG9sNkjiakwHxpmr1H3Gi3bBL8v5PbsRrH7FhpUT8acHaf2mrPKNVD894dSYXfjp6LfAbVpcCE?cluster=custom&customUrl=http%3A%2F%2Flocalhost%3A8899
Let's build it step by step!

Prerequisites
Before starting this tutorial, ensure you have:

Completed the Kora Quick Start Guide - we will use the same testing environment as the quick start guide.
Node.js (LTS or later)
Solana CLI v2.2.x or greater
Familiarity with Solana transactions and SPL tokens
A running Kora RPC server with configured signers (see Quick Start Guide for instructions)
Kora Transaction Flow
Kora enables gasless transactions by acting as a fee payer for your users' transactions. The gasless transaction flow consists of these main steps:

Transaction Creation - Build the user's intended transaction (transfers, program calls, etc.)
Fee Estimation - Create an estimate transaction to calculate required fees
Payment Instruction - Get a payment instruction from Kora that specifies the fee amount
User Signing - User signs the transaction including the payment instruction
Kora Co-signing - Kora validates payment and co-signs as the fee payer
Submission - Submit the fully-signed transaction to Solana
*Note: Kora can be configured to not require payment, but we will be using it to demonstrate the full flow.

Project Setup
Kora Server Considerations
Token Allowlist - Only tokens configured in kora.toml can be used for payment - make sure the token defined in your .env is included in your kora.toml allowlist.
Program Restrictions - Transactions can only interact with whitelisted programs. We have preset the kora.toml to allow interaction with the System Program, Token Program, Compute Unit Program, and Memo program.
Client Setup
This guide assumes you've completed the Quick Start and have the demo project set up. If not, please complete that first.

Navigate to your demo client directory:


cd kora/examples/getting-started/demo/client
Note: The demo files are located in the GitHub repository as they require a full development setup.

Implementation
Before we start running the demo, let's walk through the full demo implementation step by step:

Imports and Configuration
Our demo starts with the necessary imports and configuration:


import { KoraClient } from "@solana/kora";
import {
  createKeyPairSignerFromBytes,
  getBase58Encoder,
  createNoopSigner,
  address,
  getBase64EncodedWireTransaction,
  partiallySignTransactionMessageWithSigners,
  Blockhash,
  Base64EncodedWireTransaction,
  partiallySignTransaction,
  TransactionVersion,
  Instruction,
  KeyPairSigner,
  Rpc,
  SolanaRpcApi,
  createSolanaRpc,
  createSolanaRpcSubscriptions,
  pipe,
  createTransactionMessage,
  setTransactionMessageFeePayerSigner,
  setTransactionMessageLifetimeUsingBlockhash,
  MicroLamports,
  appendTransactionMessageInstructions,
} from "@solana/kit";
import { getAddMemoInstruction } from "@solana-program/memo";
import { createRecentSignatureConfirmationPromiseFactory } from "@solana/transaction-confirmation";
import { updateOrAppendSetComputeUnitLimitInstruction, updateOrAppendSetComputeUnitPriceInstruction } from "@solana-program/compute-budget";
import dotenv from "dotenv";
import path from "path";
dotenv.config({ path: path.join(process.cwd(), "..", ".env") });
const CONFIG = {
  computeUnitLimit: 200_000,
  computeUnitPrice: 1_000_000n as MicroLamports,
  transactionVersion: 0,
  solanaRpcUrl: "http://127.0.0.1:8899",
  solanaWsUrl: "ws://127.0.0.1:8900",
  koraRpcUrl: "http://localhost:8080/",
};
We are importing the Kora Client from the Kora SDK and a few types/helpers from Solana Kit library for building transactions.

We are also creating a global configuration object that defines:

Compute Budget - Units and price for transaction prioritization
Transaction Version - Using V0 for address lookup table support
RPC Endpoints - Local Solana and Kora RPC servers
Leave these defaults for now--after the demo, you can experiment with different values to see how they affect the transaction flow.

Utility Functions
The demo includes a helper function for loading keypairs from environment variables:


async function getEnvKeyPair(envKey: string) {
    if (!process.env[envKey]) {
        throw new Error(`Environment variable ${envKey} is not set`);
    }
    const base58Encoder = getBase58Encoder();
    const b58SecretEncoded = base58Encoder.encode(process.env[envKey]);
    return await createKeyPairSignerFromBytes(b58SecretEncoded);
}
This function:

Reads base58-encoded private keys from environment variables
Encodes the private key string to a U8 byte array
Converts them to keypair signer objects
Step 1: Initialize Clients
First, we set up our connection to both Kora and Solana:


async function initializeClients() {
    console.log('\n[1/6] Initializing clients');
    console.log('  → Kora RPC:', CONFIG.koraRpcUrl);
    console.log('  → Solana RPC:', CONFIG.solanaRpcUrl);
    
    const client = new KoraClient({
        rpcUrl: CONFIG.koraRpcUrl,
        // apiKey: process.env.KORA_API_KEY, // Uncomment if authentication is enabled
        // hmacSecret: process.env.KORA_HMAC_SECRET, // Uncomment if HMAC is enabled
    });
    const rpc = createSolanaRpc(CONFIG.solanaRpcUrl);
    const rpcSubscriptions = createSolanaRpcSubscriptions(CONFIG.solanaWsUrl);
    const confirmTransaction = createRecentSignatureConfirmationPromiseFactory({ 
        rpc, 
        rpcSubscriptions 
    });
    
    return { client, rpc, confirmTransaction };
}
This function:

Creates a Kora client instance by passing in our Kora RPC URL.
Establishes a Solana RPC connection with subscription support (we will use this for sending and confirming transactions to the Solana cluster)
Sets up transaction confirmation utilities
Note: Our kora.toml file does not include any authentication, so we don't need to pass in an api key or hmac secret, but we have left the commented out code in for reference.

Step 2: Setup Keys
Load the required keypairs from environment variables and fetch the Kora signer address:


async function setupKeys(client: KoraClient) {
    console.log('\n[2/6] Setting up keypairs');
    
    const testSenderKeypair = await getEnvKeyPair('TEST_SENDER_KEYPAIR');
    const destinationKeypair = await getEnvKeyPair('DESTINATION_KEYPAIR');
    const { signer_address } = await client.getPayerSigner();
    console.log('  → Sender:', testSenderKeypair.address);
    console.log('  → Destination:', destinationKeypair.address);
    console.log('  → Kora signer address:', signer_address);
    
    return { testSenderKeypair, destinationKeypair, signer_address };
}
Here we are using our getEnvKeyPair function to load the keypairs from the environment variables. The keypairs represent:

Sender - The user initiating the transaction and responsible for paying the Kora node in the payment token.
Destination - The recipient of the transfers.
We also use the getPayerSigner method to fetch the Kora signer address. This is the address that will be used to sign the transaction with Kora's signature. It is important that we fetch a valid signer from the Kora node and use it consistently throughout our transaction flow.

Step 3: Create Demo Instructions
Next, we build a set of instructions that that our testSender wants to send to the network. We will be using the Kora Client to build some of these instructions and the @solana/programs library to build others to demonstrate how to use both.


async function createInstructions(
    client: KoraClient, 
    testSenderKeypair: KeyPairSigner, 
    destinationKeypair: KeyPairSigner
) {
    console.log('\n[3/6] Creating demonstration instructions');
    
    const paymentToken = await client.getConfig().then(config => config.validation_config.allowed_spl_paid_tokens[0]);
    console.log('  → Payment token:', paymentToken);
    // Create token transfer (will initialize ATA if needed)
    const transferTokens = await client.transferTransaction({
        amount: 10_000_000, // 10 USDC (6 decimals)
        token: paymentToken,
        source: testSenderKeypair.address,
        destination: destinationKeypair.address
    });
    console.log('  ✓ Token transfer instruction created');
    // Create SOL transfer
    const transferSol = await client.transferTransaction({
        amount: 10_000_000, // 0.01 SOL (9 decimals)
        token: '11111111111111111111111111111111', // SOL mint address
        source: testSenderKeypair.address,
        destination: destinationKeypair.address
    });
    console.log('  ✓ SOL transfer instruction created');
    // Add memo instruction
    const memoInstruction = getAddMemoInstruction({
        memo: 'Hello, Kora!',
    });
    console.log('  ✓ Memo instruction created');
    const instructions = [
        ...transferTokens.instructions,
        ...transferSol.instructions,
        memoInstruction
    ];
    
    console.log(`  → Total: ${instructions.length} instructions`);
    return { instructions, paymentToken };
}
There's quite a bit happening here, so let's walk through it step by step:

We use getConfig to get the payment token from Kora's configuration. Because we set up our server, we know there's only one token in the allowlist, so we can access it directly in the 1st position (config.validation_config.allowed_spl_paid_tokens[0]).
We create a token transfer instruction using the Kora Client's transferTransaction method. This is a helper method that makes it easy to create a token transfer instruction.
We create a SOL transfer instruction using the Kora Client's transferTransaction method. We are including this here to show how to build SOL transfers using the Kora Client--note that we use the Native SOL mint 11111111111111111111111111111111 to indicate we want to transfer SOL instead of an SPL token transfer.
We add a memo instruction using the @solana/programs library's getAddMemoInstruction function.
We combine all the instructions into a single array. We will use this array to build our estimate transaction in the next step.
Step 4: Get Payment Instruction from Kora
Create a transaction that will generate a payment instruction to Kora in exchange for the fees required to execute the transaction.


async function getPaymentInstruction(
    client: KoraClient, 
    instructions: Instruction[],
    testSenderKeypair: KeyPairSigner,
    paymentToken: string
): Promise<{ paymentInstruction: Instruction }> {
    console.log('\n[4/6] Estimating Kora fee and assembling payment instruction');
    
    const { signer_address } = await client.getPayerSigner();
    const noopSigner = createNoopSigner(address(signer_address));
    const latestBlockhash = await client.getBlockhash();
    
    console.log('  → Fee payer:', signer_address.slice(0, 8) + '...');
    console.log('  → Blockhash:', latestBlockhash.blockhash.slice(0, 8) + '...');
    // Create estimate transaction to get payment instruction
    const estimateTransaction = pipe(
        createTransactionMessage({ version: CONFIG.transactionVersion as TransactionVersion }),
        (tx) => setTransactionMessageFeePayerSigner(noopSigner, tx),
        (tx) => setTransactionMessageLifetimeUsingBlockhash({
        blockhash: latestBlockhash.blockhash as Blockhash,
        lastValidBlockHeight: 0n,
        }, tx),
        (tx) => updateOrAppendSetComputeUnitPriceInstruction(CONFIG.computeUnitPrice, tx),
        (tx) => updateOrAppendSetComputeUnitLimitInstruction(CONFIG.computeUnitLimit, tx),
        (tx) => appendTransactionMessageInstructions(instructions, tx),
    );
    const signedEstimateTransaction = await partiallySignTransactionMessageWithSigners(estimateTransaction);
    const base64EncodedWireTransaction = getBase64EncodedWireTransaction(signedEstimateTransaction);
    console.log('  ✓ Estimate transaction built');
    // Get payment instruction from Kora
    const paymentInstruction = await client.getPaymentInstruction({
        transaction: base64EncodedWireTransaction,
        fee_token: paymentToken,
        source_wallet: testSenderKeypair.address,
    });
    console.log('  ✓ Payment instruction received from Kora');
    
    return { paymentInstruction: paymentInstruction.payment_instruction };
}
The Kora SDK has a helper method getPaymentInstruction that will calculate the exact fees required for the transaction and create a payment transfer instruction. Here's how we're using it:

First, we create an estimateTransaction that includes our desired instructions--this transaction will be simulated on the Kora server to estimate the fees required for the transaction.
We then partially sign the transaction to get a base64 encoded wire string.
We pass our base64 encoded wire transaction to the getPaymentInstruction method with the payment token and source of the payment. This will return an Instruction object that we can add to our transaction.
Key concepts here:

Valid Blockhash - We use the getBlockhash method to get a valid blockhash for our transaction. This is required for estimating the transaction as it will simulate the transaction on the server.
Noop Signer - Placeholder signer used when building transactions before Kora signs. This will allow us to specify a fee payer in our transaction before we have Kora's signature. For more information on Noop Signers, see Solana Kit Documentation.
Partial Signing - In order to get our transaction as a base64 encoded wire string (we need this to send the transaction via the Kora RPC), we need to partially sign the transaction. For more information on Partial Signers, see Solana Kit Documentation.
Step 5: Create and Sign Final Transaction
Now that we have our payment instruction, we can create a final transaction that includes our original instructions and the payment instruction.


async function getFinalTransaction(
    client: KoraClient, 
    paymentInstruction: Instruction,
    testSenderKeypair: KeyPairSigner, 
    instructions: Instruction[], 
    signer_address: string
): Promise<Base64EncodedWireTransaction> {
    console.log('\n[5/6] Creating and signing final transaction (with payment)');
    const noopSigner = createNoopSigner(address(signer_address));
    // Build final transaction with payment instruction
    const newBlockhash = await client.getBlockhash();
    const fullTransaction = pipe(
        createTransactionMessage({ version: CONFIG.transactionVersion as TransactionVersion }),
        (tx) => setTransactionMessageFeePayerSigner(noopSigner, tx),
        (tx) => setTransactionMessageLifetimeUsingBlockhash({
        blockhash: newBlockhash.blockhash as Blockhash,
        lastValidBlockHeight: 0n,
        }, tx),
        (tx) => updateOrAppendSetComputeUnitPriceInstruction(CONFIG.computeUnitPrice, tx),
        (tx) => updateOrAppendSetComputeUnitLimitInstruction(CONFIG.computeUnitLimit, tx),
        (tx) => appendTransactionMessageInstructions([...instructions, paymentInstruction], tx),
    );
    console.log('  ✓ Final transaction built with payment');
    // Sign with user keypair
    const signedFullTransaction = await partiallySignTransactionMessageWithSigners(fullTransaction);
    const userSignedTransaction = await partiallySignTransaction([testSenderKeypair.keyPair], signedFullTransaction);
    const base64EncodedWireFullTransaction = getBase64EncodedWireTransaction(userSignedTransaction);
    console.log('  ✓ Transaction signed by user');
    
    return base64EncodedWireFullTransaction;
}
We use the same pipe function to assemble our transaction. Our final transaction includes:

Our original instructions
The payment instruction
A fresh blockhash
The same noop signer as previously used to build the estimate transaction
We then call the same partiallySignTransactionMessageWithSigners function to get a base64 encoded wire string of the transaction. This time, however, we also run partiallySignTransaction to sign the transaction with our testSenderKeypair. Though our Kora node is paying the network fees, our testSender still needs to sign to authorize the token payment and the other transfer instructions we created. For Kora nodes that do not require payment, certain instructions may not require this signing step. Finally, we return the base64 encoded wire string of the transaction.

Step 6: Submit Transaction
Finally, we need to get the Kora node to sign the transaction so we can send a fully signed transaction to the network. We do this by calling the signTransaction method on the Kora client.


async function submitTransaction(
    client: KoraClient, 
    rpc: Rpc<SolanaRpcApi>, 
    confirmTransaction: ReturnType<typeof createRecentSignatureConfirmationPromiseFactory>, 
    signedTransaction: Base64EncodedWireTransaction, 
    signer_address: string
) {
    console.log('\n[6/6] Signing transaction with Kora and sending to Solana cluster');
    
    // Get Kora's signature
    const { signed_transaction } = await client.signTransaction({
        transaction: signedTransaction,
        signer_key: signer_address
    });
    console.log('  ✓ Transaction co-signed by Kora');
    // Submit to Solana network
    const signature = await rpc.sendTransaction(signed_transaction as Base64EncodedWireTransaction, {
        encoding: 'base64'
    }).send();
    console.log('  ✓ Transaction submitted to network');
    
    console.log('  ⏳ Awaiting confirmation...');
    await confirmTransaction({
        commitment: 'confirmed',
        signature,
        abortSignal: new AbortController().signal
    });
    
    console.log('\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
    console.log('SUCCESS: Transaction confirmed on Solana');
    console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
    console.log('\nTransaction signature:');
    console.log(signature);
    
    return signature;
}
Here we are doing three things:

We call the signTransaction method on the Kora client to get the Kora node to sign the transaction. The node will introspect the transaction to ensure the payment is sufficient and then sign the transaction. Note: some Kora nodes may enable signTransaction that do not require payment. You can check your node's configuration to see if this is enabled by running getConfig().
We send the fully signed transaction to the Solana network using the Solana RPC client.
We wait for the transaction to be confirmed on the network.
Main Orchestration Function
The main function ties everything together and calls each of our functions in sequence:


async function main() {
    console.log('\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
    console.log('KORA GASLESS TRANSACTION DEMO');
    console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
    
    try {
        // Step 1: Initialize clients
        const { client, rpc, confirmTransaction } = await initializeClients();
        
        // Step 2: Setup keys
        const { testSenderKeypair, destinationKeypair, signer_address } = await setupKeys(client);
        
        // Step 3: Create demo instructions
        const { instructions, paymentToken } = await createInstructions(client, testSenderKeypair, destinationKeypair);
        
        // Step 4: Get payment instruction from Kora
        const { paymentInstruction } = await getPaymentInstruction(client, instructions, testSenderKeypair, paymentToken);
        
        // Step 5: Create and partially sign final transaction
        const finalSignedTransaction = await getFinalTransaction(
            client,  
            paymentInstruction, 
            testSenderKeypair, 
            instructions, 
            signer_address
        );
        
        // Step 6: Get Kora's signature and submit to Solana cluster
        await submitTransaction(client, rpc, confirmTransaction, finalSignedTransaction, signer_address);
    } catch (error) {
        console.error('\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
        console.error('ERROR: Demo failed');
        console.error('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
        console.error('\nDetails:', error);
        process.exit(1);
    }
}
Running the Full Demo
To run the complete gasless transaction demo:

1. Ensure Prerequisites
Set up three terminal windows:

Start your local test validator:

solana-test-validator -r
Start your Kora RPC server (from the examples/getting-started/demo/server directory):

kora rpc start --signers-config signers.toml
Initialize your environment (from the examples/getting-started/demo/client directory):

pnpm init-env
2. Run the Demo

# From the client directory
pnpm full-demo
3. Expected Output
You should see the step-by-step execution with a successful transaction at the end. The transaction will:

Transfer tokens from sender to destination
Transfer SOL from sender to destination
Include a "Hello, Kora!" memo message
Pay fees to the Kora node operator in your configured SPL token
Have transaction gas fees paid by the Kora node operator
Recap: Understanding the Flow
Let's review what happens in this demonstration:

User Intent - User assembled a transaction that included a variety of instructions that they wanted to execute.
Fee Estimation - Kora calculated the transaction cost in the user's preferred token and created a payment instruction.
Transaction Assembly - User assembled a final transaction that included the user's intended instructions and the Kora payment instruction.
Transaction Signing - User partially signed the transaction with their keypair and sent to the Kora node for signing after verifying the payment was sufficient.
Atomic Execution - User sends transaction to the Solana and everything happens in a single transaction:
User's intended transfers execute
Payment for fees transfers to Kora
Kora pays the Solana network fees and signs the transaction
And like that, users do not need to hold SOL to pay for gas fees--they can pay for everything in the tokens they already hold!

Troubleshooting
Common Issues
Transaction Validation Fails

Verify all programs are whitelisted in kora.toml
Check that token mints are in allowed_spl_paid_tokens
Ensure transaction doesn't exceed max_allowed_lamports
Generating Payment Instruction Fails

Confirm the estimate transaction has a fresh blockhash for simulation
Verify Kora's payment address has initialized ATAs
Check that the payment token is properly configured
Signature Verification Fails

Ensure all required signers are included (Kora and any signers required for token payments or other instructions included in your transaction)
Verify the transaction hasn't been modified after signing
Check that keypairs are loaded correctly
Wrap Up
Congratulations! You've successfully implemented a complete gasless transaction flow with Kora.

Kora makes it possible to provide users with a seamless Web3 experience where they never need to worry about gas fees or holding SOL. Whether you're building a NeoBank, gaming platform, or liquid staking platform, Kora's gasless transactions remove a major barrier to user adoption.

Additional Resources
Need help? Ask questions on Solana Stack Exchange with a Kora tag
Kora Configuration Guide - Detailed configuration options
Signers Guide - Managing different signer types
API Reference - Complete RPC method documentation
GitHub Repository - Source code and examples
Kora SDK - SDK for interacting with Kora RPC endpoints

How to Implement Gasless Transaction Bundles with Jito and Kora
This guide teaches you how to implement gasless Jito Bundles using Kora.

Last Updated: 2025-01-09

What You'll Build
In the Full Transaction Flow Guide, you learned how to create gasless transactions using Kora. There are many scenarios, however, where a single transaction is inadequate OR there is insufficient space in a single transaction to include a Kora payment instruction. In this guide, we will build a demo that demonstrates how to use Kora to sign and send a bundle of transactions to Jito's block engine for atomic execution on Solana Mainnet. The Kora server will pay the Jito tip and all transaction fees.

The final result will be a working Jito bundle system:


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
KORA JITO BUNDLE DEMO
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[1/5] Initializing clients
  → Kora RPC: http://localhost:8080/
  → Solana RPC: https://api.mainnet-beta.solana.com
[2/5] Setting up keypairs
  → Sender: BYJVBqQ2xV9GECc84FeoPQy2DpgoonZQFQu97MMWTbBc
  → Kora signer address: 3Z1Ef7YaxK8oUMoi6exf7wYZjZKWJJsrzJXSt1c3qrDE
[3/5] Creating bundle transactions
  → Blockhash: 7HZUaMqV...
  → Tip account: 96gYZGLn...
  → Transaction 1: Kora Memo "Bundle tx #1"
  → Transaction 2: Kora Memo "Bundle tx #2"
  → Transaction 3: Kora Memo "Bundle tx #3"
  → Transaction 4: Kora Memo "Bundle tx #4" + Jito tip
  ✓ 4 transactions created for bundle
[4/5] Signing bundle with Kora
  ✓ All transactions signed by user
  ✓ Bundle co-signed by Kora
  → 4 transactions signed
[5/5] Submitting bundle to Jito
  ✓ Bundle submitted to Jito block engine
  → Bundle UUID: 8f4a3b2c-1d5e-6f7a-8b9c-0d1e2f3a4b5c
  ⏳ Polling bundle status...
  ✓ Bundle landed (simulated for demo)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
SUCCESS: Bundle confirmed on Solana
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Bundle UUID:
8f4a3b2c-1d5e-6f7a-8b9c-0d1e2f3a4b5c
Here's how we build it.

Prerequisites
Before starting this tutorial, ensure you have:

Completed the Kora Full Transaction Flow Guide - we build on those concepts
Node.js (LTS or later)
Familiarity with Solana transactions
Familiarity with Jito Bundles
Kora 2.2 Release Candidate
Important: This guide is built on the Kora 2.2 Release Candidate branch. You can find the branch here. This branch is unaudited and may contain bugs. Please use at your own risk.

You will need to install the Kora 2.2 Release Candidate:


cargo install kora-cli@2.2.0-beta.2
Jito Bundles Basics
On Solana, every instruction in a transaction is atomic—if one instruction fails, the entire transaction fails. Bundles are a tool that enable you to execute up to 5 transactions atomically and sequentially. Bundles are incentivized by a tip, the higher the tip, the higher the priority.

This guide assumes you have some basic understanding of and experience with Jito Bundles.

Project Structure
The sample code for this demo can be found in the Kora 2.2 Release Candidate Branch here:


jito-bundles/
├── client/
│   ├── src/
│   │   └── index.ts       # Bundle demo implementation
│   └── package.json
├── server/
│   ├── kora.toml          # Kora configuration with bundles enabled
│   └── signers.toml       # Signer configuration
└── scripts/
    └── start-kora.sh      # Server startup script
Clone the kora repository and navigate to the jito-bundles directory:


git clone https://github.com/solana-foundation/kora.git
cd kora/examples/jito-bundles
Kora Server Configuration
kora.toml
The key configuration for bundle support:


[kora]
rate_limit = 100
[kora.auth]
api_key = "kora_facilitator_api_key_example"
[kora.enabled_methods]
sign_bundle = true
sign_and_send_bundle = true
estimate_bundle_fee = true
get_blockhash = true
get_config = true
get_payer_signer = true
[validation]
max_allowed_lamports = 1000000
max_signatures = 10
price_source = "Mock"
allowed_programs = [
    "11111111111111111111111111111111",            # System Program
    "MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr", # Memo Program
]
[validation.fee_payer_policy.system]
allow_transfer = true  # Required for Jito tip transfers
[validation.price]
type = "free"  # No payment required for this demo
[kora.bundle]
enabled = true
[kora.bundle.jito]
block_engine_url = "https://mainnet.block-engine.jito.wtf"
Important settings for bundle support:

sign_bundle / sign_and_send_bundle - Enable the bundle RPC methods
allow_transfer = true - Kora's signer pays the Jito tip, so it needs transfer permission
bundle.enabled = true - Master switch for bundle functionality
We are using the public mainnet block engine URL for this demo. In production, you would use the private block engine url.
signers.toml

[signer_pool]
strategy = "round_robin"
[[signers]]
name = "main_signer"
type = "memory"
private_key_env = "KORA_PRIVATE_KEY"
Make sure to rename .env.example to .env and set the KORA_PRIVATE_KEY environment variable to your mainnet private key. The signer wallet needs SOL on mainnet to pay:

Transaction fees for all bundle transactions
The Jito tip (minimum 1,000 lamports)
Important: This guide demonstrates using Jito tips on Solana Mainnet. Tips are non-refundable.

Starting the Server
From the server/ directory:


kora --config kora.toml --rpc-url https://api.mainnet-beta.solana.com rpc start --signers-config signers.toml
Or use the provided script. From the server/ directory:


../scripts/start-kora.sh
Great! You are running a Kora server with bundle support enabled on Solana Mainnet.

Client Implementation
We'll walk through the client implementation step by step, starting with imports.

Imports and Configuration

import { KoraClient } from "@solana/kora";
import {
  createNoopSigner,
  address,
  getBase64EncodedWireTransaction,
  partiallySignTransactionMessageWithSigners,
  Blockhash,
  KeyPairSigner,
  pipe,
  createTransactionMessage,
  setTransactionMessageFeePayerSigner,
  setTransactionMessageLifetimeUsingBlockhash,
  appendTransactionMessageInstruction,
  generateKeyPairSigner,
} from "@solana/kit";
import { getAddMemoInstruction } from "@solana-program/memo";
import { getTransferSolInstruction } from "@solana-program/system";
const MINIMUM_JITO_TIP = 1_000n; // lamports
const CONFIG = {
  solanaRpcUrl: "https://api.mainnet-beta.solana.com",
  koraRpcUrl: "http://localhost:8080/",
  jitoTipLamports: MINIMUM_JITO_TIP,
  bundleSize: 4, // We'll create 4 transactions for this demo
  pollIntervalMs: 6000,
  pollTimeoutMs: 60000,
};
We're setting up:

Solana Kit imports for building transactions
Memo program for our demo transactions (you'd replace with real operations)
System program for the Jito tip transfer
Configuration for RPC endpoints and bundle parameters
Jito Tip Accounts
Jito has 8 tip accounts that you can send SOL to. We select one at random for this demo.


// Jito tip accounts - one is randomly selected by the block engine
const JITO_TIP_ACCOUNTS = [
  "96gYZGLnJYVFmbjzopPSU6QiEV5fGqZNyN9nmNhvrZU5",
  "HFqU5x63VTqvQss8hp11i4wVV8bD44PvwucfZ2bU7gRe",
  "Cw8CFyM9FkoMi7K7Crf6HNQqf4uEMzpKw6QNghXLvLkY",
  "ADaUMid9yfUytqMBgopwjb2DTLSokTSzL1zt6iGPaS49",
  "DfXygSm4jCyNCybVYYK6DwvWqjKee8pbDmJGcLWNDXjh",
  "ADuUkR4vqLUMWXxW9gh6D6L8pMSawimctcNZ5pGwDcEt",
  "DttWaMuVvTiduZRnguLF7jNxTgiMBZ1hyAumKUiL2KRL",
  "3AVi9Tg9Uo68tJfuvoKvqKNWKkC5wPdSSdeBnizKZ6jT",
];
function getRandomTipAccount(): string {
  return JITO_TIP_ACCOUNTS[
    Math.floor(Math.random() * JITO_TIP_ACCOUNTS.length)
  ];
}
The tip accounts are Jito-operated addresses. Sending SOL to any of them signals your tip amount to validators.

Step 1: Initialize Clients
We initialize the Kora client with our API key, which matches what's configured in kora.toml. In production, you'd load this from an environment variable.


async function initializeClients() {
  console.log("\n[1/4] Initializing clients");
  console.log("  → Kora RPC:", CONFIG.koraRpcUrl);
  console.log("  → Solana RPC:", CONFIG.solanaRpcUrl);
  const client = new KoraClient({
    rpcUrl: CONFIG.koraRpcUrl,
    apiKey: 'kora_facilitator_api_key_example', // Make sure this matches what's configured in kora.toml
  });
  return { client };
}
Step 2: Setup Keys

async function setupKeys(client: KoraClient) {
  console.log("\n[2/4] Setting up keypairs");
  const senderKeypair = await generateKeyPairSigner();
  console.log("  → Sender:", senderKeypair.address);
  const { signer_address } = await client.getPayerSigner();
  console.log("  → Kora signer address:", signer_address);
  return { senderKeypair, signer_address };
}
We use generateKeyPairSigner() to create a fresh keypair for the demo. Because the keypair is only signing the memo instructions and does not have to pay any Kora fees (per our configuration), no SOL or other tokens are needed. Kora's signer (fetched via getPayerSigner) pays all fees and the Jito tip.

Step 3: Create Bundle Transactions
Now let's create a bundle of transactions. We create multiple transactions, each with its own unique instructions. We use unique memo instructions here to easily verify our transactions after they land on Solana Mainnet.


async function createBundleTransactions(
  client: KoraClient,
  senderKeypair: KeyPairSigner,
  signer_address: string
) {
  console.log("\n[3/4] Creating bundle transactions");
  const noopSigner = createNoopSigner(address(signer_address));
  const latestBlockhash = await client.getBlockhash();
  const tipAccount = getRandomTipAccount();
  console.log("  → Blockhash:", latestBlockhash.blockhash.slice(0, 8) + "...");
  console.log("  → Tip account:", tipAccount.slice(0, 8) + "...");
  const transactions: string[] = [];
  for (let i = 0; i < CONFIG.bundleSize; i++) {
    const isLastTransaction = i === CONFIG.bundleSize - 1;
    console.log(
      `  → Transaction ${i + 1}: Kora Memo "Bundle tx #${i + 1}"${
        isLastTransaction ? " + Jito tip" : ""
      }`
    );
    // Build transaction with memo
    let transactionMessage = pipe(
      createTransactionMessage({
        version: 0,
      }),
      (tx) => setTransactionMessageFeePayerSigner(noopSigner, tx),
      (tx) =>
        setTransactionMessageLifetimeUsingBlockhash(
          {
            blockhash: latestBlockhash.blockhash as Blockhash,
            lastValidBlockHeight: 0n,
          },
          tx
        ),
      (tx) =>
        appendTransactionMessageInstruction(
          getAddMemoInstruction({
            memo: `Kora Bundle tx #${i + 1} of ${CONFIG.bundleSize}`,
            signers: [senderKeypair],
          }),
          tx
        ),
      // Add Jito tip to the LAST transaction only
      (tx) =>
        isLastTransaction
          ? appendTransactionMessageInstruction(
              getTransferSolInstruction({
                source: noopSigner,
                destination: address(tipAccount),
                amount: CONFIG.jitoTipLamports,
              }),
              tx
            )
          : tx
    );
    // Sign with sender keypair (required for memo instruction)
    const signedTransaction = await partiallySignTransactionMessageWithSigners(
      transactionMessage
    );
    const base64Transaction =
      getBase64EncodedWireTransaction(signedTransaction);
    transactions.push(base64Transaction);
  }
  console.log(`  ✓ ${transactions.length} transactions created for bundle`);
  return transactions;
}
Important: Tip paid by Kora signer: Since we want the Kora node to pay our Jito tip, we use a "no-op" signer (noopSigner), where Kora's address is the source of the tip transfer. Kora will sign this when processing the bundle.

Step 4: Sign and Submit Bundle
Now we can pull it together and send the bundle to Kora for signing and submission to Jito's block engine.


async function main() {
  console.log("\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
  console.log("KORA JITO BUNDLE DEMO");
  console.log("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
  try {
    // Step 1: Initialize clients
    const { client } = await initializeClients();
    // Step 2: Setup keys
    const { senderKeypair, signer_address } = await setupKeys(client);
    // Step 3: Create bundle transactions
    const transactions = await createBundleTransactions(
      client,
      senderKeypair,
      signer_address
    );
    // Step 4: Sign and send bundle
    console.log("\n[4/4] Signing and sending bundle");
    const { bundle_uuid } = await client.signAndSendBundle({
      transactions,
      signer_key: signer_address,
    });
    console.log("\nBundle UUID:");
    console.log(bundle_uuid);
  } catch (error) {
    console.error("\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
    console.error("ERROR: Demo failed");
    console.error("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
    console.error("\nDetails:", error);
    process.exit(1);
  }
}
main().catch((e) => console.error("Error:", e));
Running the Demo
1. Start the Kora Server

cd examples/jito-bundles/server
# Start Kora
kora --config kora.toml --rpc-url https://api.mainnet-beta.solana.com rpc start --signers-config signers.toml
2. Run the Client
In a new terminal, navigate to the client/ directory and run the demo:


cd examples/jito-bundles/client
# Install dependencies
pnpm install
# Run the demo
pnpm start
Expected Output
You should see the step-by-step execution with a successful bundle at the end. The bundle will:

Create 4 memo transactions
Add a Jito tip (1,000 lamports) to the last transaction
Have all transactions signed by Kora as fee payer
Submit atomically to Jito's block engine
Note:

Jito's default router can hit rate limits. If you get a 429 error, you can try again later or request higher limits. Check out Jito's rate limiting documentation for more information.
Because our demo is using a very small tip, the bundle may not land on Solana Mainnet. If you don't see the bundle on Jito's bundle explorer, you can try again later with a higher tip.
Understanding What Happened
Here's what happened differently from single transactions:

Multiple Transactions - Instead of one transaction, we created 4 that must execute together
Jito Tip - We added a tip transfer (paid by Kora's signer) to incentivize validators
Bundle Validation - Kora validated all transactions meet requirements specified in kora.toml
Atomic Submission - All transactions submitted as a single unit to Jito by our Kora server with all fees and tips paid by Kora's signer
The result: either all 4 transactions execute in sequence, or none do. No partial states.

Wrap Up
You've now implemented gasless transaction bundles with Kora and Jito. With Jito Bundles combined with Kora's gasless transaction support, you can provide users with seamless experiences for even the most complex operations.

Additional Resources
Need help? Ask questions on Solana Stack Exchange with a Kora tag
Jito Documentation - Official Jito MEV documentation
API Reference - signBundle and signAndSendBundle methods
GitHub Repository - Source code and examples
On this page
What You'll Build
Prerequisites
Kora 2.2 Release Candidate
Jito Bundles Basics
Project Structure
Kora Server Configuration
kora.toml
signers.toml
Starting the Server
Client Implementation
Imports and Configuration
Jito Tip Accounts
Step 1: Initialize Clients
Step 2: Setup Keys
Step 3: Create Bundle Transactions
Step 4: Sign and Submit Bundle
Running the Demo
1. Start the Kora Server
2. Run the Client
Expected Output
Understanding What Happened
Wrap Up
Additional Resources

